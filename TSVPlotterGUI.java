import javax.swing.*;
import java.awt.*;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.List; // Added explicitly
import java.util.ArrayList; // Added explicitly
import java.util.stream.Collectors;
import javax.swing.table.DefaultTableModel;


/**
 * GUI class for the TSVPlotter application.
 * Handles user interaction, including input for gene name and Precursor.Id selection,
 * and displays the chart generated by TSVPlotter.
 * Contains the main method to start the program.
 * 
 * Dependencies:
 * - Uses TSVPlotter (in TSVPlotter.java) for core plotting logic.
 */
public class TSVPlotterGUI {
    /**
     * Main method to start the program.
     * Parses command-line arguments, initializes TSVPlotter, and sets up the GUI for user interaction.
     * @param args Command-line arguments:
     *             --input <tsv_file>: Path to the TSV file (required).
     *             --load-all: Optional flag to load the entire file into memory.
     */
    public static void main(String[] args) {
        // Parse command-line arguments
        String filePath = null;
        boolean loadAll = false;
        for (int i = 0; i < args.length; i++) {
            if (args[i].equals("--input") && i + 1 < args.length) {
                filePath = args[i + 1];
                i++;
            } else if (args[i].equals("--load-all")) {
                loadAll = true;
            }
        }

        if (filePath == null) {
            System.err.println("Usage: java TSVPlotterGUI --input <tsv_file> [--load-all]");
            System.exit(1);
        }

        final String finalFilePath = filePath; // Make filePath effectively final for lambda
        final boolean finalLoadAll = loadAll;  // Make loadAll effectively final for lambda
        TSVPlotter plotter = new TSVPlotter();

        // Load the file once at startup
        try {
            plotter.loadTSV(finalFilePath, finalLoadAll);
        } catch (IOException ex) {
            System.err.println("Error loading TSV file at startup: " + ex.getMessage());
            System.exit(1);
        }

        // Create GUI
        JFrame frame = new JFrame("TSV Plotter");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setLayout(new BorderLayout());

        // Gene input panel
        JPanel inputPanel = new JPanel();
        JLabel geneLabel = new JLabel("Enter Gene Name:");
        JTextField geneField = new JTextField(20);
        JButton fetchButton = new JButton("Fetch Precursor.Id Values");
        inputPanel.add(geneLabel);
        inputPanel.add(geneField);
        inputPanel.add(fetchButton);

        // Precursor.Id selection panel (now just a button, table will be shown separately)
        JPanel precursorPanel = new JPanel();
        JButton plotButton = new JButton("Plot Chart");
        precursorPanel.add(plotButton);

        frame.add(inputPanel, BorderLayout.NORTH);
        frame.add(precursorPanel, BorderLayout.CENTER);

        // Table to display Precursor.Id values (will be created dynamically)
        final JTable[] precursorTable = {null}; // Use an array to make it effectively final for lambda
        final DefaultTableModel[] tableModel = {null}; // Use an array to make it effectively final for lambda
        final String[] currentGene = {null}; // Store the current gene for use in plotButton
        final JTable[] fileNameTable = {null}; // Store the File.Name alias table for use in plotButton

        // Action listeners
        fetchButton.addActionListener(e -> {
            final String gene = geneField.getText().trim(); // Make gene effectively final for lambda
            if (gene.isEmpty()) {
                JOptionPane.showMessageDialog(frame, "Please enter a gene name", "Error", JOptionPane.ERROR_MESSAGE);
                return;
            }

            // Filter the in-memory records list to get Precursor.Id values
            Set<String> precursorIds = plotter.getUniquePrecursorIds(gene);
            if (precursorIds.isEmpty()) {
                JOptionPane.showMessageDialog(frame, "No Precursor.Id values found for gene: " + gene, 
                                              "Info", JOptionPane.INFORMATION_MESSAGE);
                return;
            }

            // Calculate the number of records for each Precursor.Id
            Map<String, Integer> precursorIdCounts = new HashMap<>();
            for (String precursorId : precursorIds) {
                long count = plotter.getRecords().stream()
                                    .filter(record -> record.gene.equals(gene) && record.precursorId.equals(precursorId))
                                    .count();
                precursorIdCounts.put(precursorId, (int) count);
            }

            // Sort Precursor.Id values by record count in descending order
            List<String> sortedPrecursorIds = new ArrayList<>(precursorIds);
            sortedPrecursorIds.sort((id1, id2) -> precursorIdCounts.get(id2).compareTo(precursorIdCounts.get(id1)));

            // Get the total number of unique File.Name values
            Set<String> allFileNames = plotter.getRecords().stream()
                                                     .map(Record::getOriginalFileName)
                                                     .collect(Collectors.toSet());
            int totalFiles = allFileNames.size();

            // Create a table to display Precursor.Id and record counts in sorted order
            String[] columnNames = {"Precursor.Id", "Records Found / Total Files"};
            Object[][] tableData = new Object[sortedPrecursorIds.size()][2];
            int row = 0;
            for (String precursorId : sortedPrecursorIds) {
                tableData[row][0] = precursorId;
                tableData[row][1] = precursorIdCounts.get(precursorId) + " / " + totalFiles;
                row++;
            }

            // Display the Precursor.Id table in a new JFrame
            tableModel[0] = new DefaultTableModel(tableData, columnNames);
            precursorTable[0] = new JTable(tableModel[0]);
            precursorTable[0].setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION); // Allow multiple row selections
            JScrollPane scrollPane = new JScrollPane(precursorTable[0]);
            JFrame tableFrame = new JFrame("Precursor.Id Counts for Gene: " + gene);
            tableFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
            tableFrame.add(scrollPane);
            tableFrame.setSize(400, 300);
            tableFrame.setLocation(100, 100); // Position the first table
            tableFrame.setVisible(true);

            // Create a second table to display the list of File.Name aliases
            Map<String, String> fileNameToAlias = plotter.getFileNameToAlias();
            // Get unique aliases, filtering out invalid ones (e.g., "1", "2")
            Set<String> uniqueAliases = new TreeSet<>(); // TreeSet for sorted order
            for (String alias : fileNameToAlias.values()) {
                if (alias != null && !alias.matches("\\d+")) { // Exclude aliases that are just digits
                    uniqueAliases.add(alias);
                }
            }

            // Create the table data for File.Name aliases
            String[] fileNameColumnNames = {"File.Name Alias"};
            Object[][] fileNameTableData = new Object[uniqueAliases.size()][1];
            int i = 0;
            for (String alias : uniqueAliases) {
                fileNameTableData[i][0] = alias;
                i++;
            }

            // Display the File.Name table in a new JFrame
            fileNameTable[0] = new JTable(fileNameTableData, fileNameColumnNames);
            fileNameTable[0].setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION); // Allow multiple row selections
            JScrollPane fileNameScrollPane = new JScrollPane(fileNameTable[0]);
            JFrame fileNameTableFrame = new JFrame("File.Name Aliases for Gene: " + gene);
            fileNameTableFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
            fileNameTableFrame.add(fileNameScrollPane);
            fileNameTableFrame.setSize(400, 300);
            fileNameTableFrame.setLocation(500, 100); // Position the second table to the right of the first
            fileNameTableFrame.setVisible(true);

            currentGene[0] = gene; // Store the current gene for use in plotButton
        });

        plotButton.addActionListener(e -> {
            if (currentGene[0] == null || precursorTable[0] == null || fileNameTable[0] == null) {
                JOptionPane.showMessageDialog(frame, "Please fetch Precursor.Id values first", 
                                              "Error", JOptionPane.ERROR_MESSAGE);
                return;
            }

            // Get the selected Precursor.Id values from the table
            int[] selectedPrecursorRows = precursorTable[0].getSelectedRows();
            if (selectedPrecursorRows.length == 0) {
                JOptionPane.showMessageDialog(frame, "Please select at least one Precursor.Id from the table", 
                                              "Error", JOptionPane.ERROR_MESSAGE);
                return;
            }

            List<String> selectedPrecursorIds = new ArrayList<>();
            for (int row : selectedPrecursorRows) {
                String precursorId = (String) precursorTable[0].getValueAt(row, 0);
                selectedPrecursorIds.add(precursorId);
            }

            // Get the selected File.Name aliases from the table
            int[] selectedFileNameRows = fileNameTable[0].getSelectedRows();
            if (selectedFileNameRows.length == 0) {
                JOptionPane.showMessageDialog(frame, "Please select at least one File.Name alias from the table", 
                                              "Error", JOptionPane.ERROR_MESSAGE);
                return;
            }

            List<String> selectedFileNameAliases = new ArrayList<>();
            for (int row : selectedFileNameRows) {
                String fileNameAlias = (String) fileNameTable[0].getValueAt(row, 0);
                selectedFileNameAliases.add(fileNameAlias);
            }

            // Plot the chart with the selected Precursor.Id values and File.Name aliases
            JFrame chartFrame = plotter.plotChart(currentGene[0], selectedPrecursorIds, selectedFileNameAliases);
            chartFrame.setVisible(true);
        });

        frame.pack();
        frame.setVisible(true);
    }
}